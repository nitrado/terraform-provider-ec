package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html"
	"reflect"
	"strings"
	"text/template"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/nitrado/tfconv/schemagen"
)

// Generator is a struct Terraform schema generator. It converts structs
// into Terraform schemas returned by a function.
type Generator struct {
	gen *schemagen.Generator

	seen map[reflect.Type]string
}

// NewGenerator return a new Terraform schema generator.
func NewGenerator() *Generator {
	g := &Generator{
		seen: map[reflect.Type]string{},
	}

	g.gen = schemagen.New(g.docs, g.customize, "json")

	return g
}

// Generate generates a Terraform schema for the given object.
func (g *Generator) Generate(obj any, pkgName, fnName string) ([]byte, error) {
	fields, err := g.gen.Struct(obj)
	if err != nil {
		return nil, err
	}

	var needsMeta bool
	for _, s := range fields {
		if strings.Contains(s, "meta.") {
			needsMeta = true
		}
	}

	buf := &bytes.Buffer{}
	err = fileTmpl.Execute(buf, struct {
		PkgName   string
		FuncName  string
		Fields    map[string]string
		NeedsMeta bool
	}{
		PkgName:   pkgName,
		FuncName:  fnName,
		Fields:    fields,
		NeedsMeta: needsMeta,
	})
	if err != nil {
		return nil, err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("formatting schema: %w", err)
	}

	g.seen[reflect.TypeOf(obj)] = fnName

	return formatted, nil
}

type docable interface {
	Docs() map[string]string
}

func (g *Generator) docs(obj any, sf reflect.StructField) string {
	docsObj, hasDocs := obj.(docable)
	if !hasDocs {
		return ""
	}

	name := g.gen.ResolveName(sf)
	return html.UnescapeString(docsObj.Docs()[name])
}

type attrable interface {
	Attributes() map[string]string
}

func (g *Generator) customize(obj any, sf *reflect.StructField, typ reflect.Type, s *schema.Schema) (fn string, out reflect.Kind, ok bool) {
	kind := typ.Kind()

	if sf != nil {
		switch sf.Name {
		case "TypeMeta", "Status":
			return "", kind, false
		}

		s.Optional = true
		attrObj, hasAttrs := obj.(attrable)
		if hasAttrs {
			attr := attrObj.Attributes()

			name := g.gen.ResolveName(*sf)
			switch attr[name] {
			case "readonly":
				s.Optional = false
				s.Computed = true
			case "required":
				s.Optional = false
				s.Required = true
			default:
				s.Optional = true
			}
		}
	}

	if fnName, found := g.seen[typ]; found {
		return fnName, kind, true
	}

	switch typ.String() {
	case "resource.Quantity":
		return "", reflect.String, true
	case "v1.ObjectMeta":
		return "meta.Schema", kind, true
	}

	return "", kind, true
}

var fileTmpl = template.Must(template.New("code").Parse(`package {{.PkgName}}

// Code generated by schema-gen. DO NOT EDIT.

{{ if .NeedsMeta }}
import (
    "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
    "github.com/nitrado/terraform-provider-ec/ec/meta"
)
{{- else }}
import "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
{{- end }}

func {{.FuncName}}() map[string]*schema.Schema {
    return map[string]*schema.Schema{
{{- range $name, $schema := .Fields }}
	    "{{ $name }}": {{ $schema }},
{{- end }}
    }
}
`))
